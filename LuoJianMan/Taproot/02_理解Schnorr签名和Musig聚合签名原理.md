# 理解Schnorr签名和Musig聚合签名原理

## 大纲

1. [Schnorr签名](#Schnorr签名)
   + [椭圆曲线中的加密方式](#椭圆曲线中的加密方式)
   + [Schnorr签名的实现原理](#Schnorr签名的实现原理)
      + [对消息进行签名](#对消息进行签名)
      + [对签名进行验证](#对签名进行验证)
      + [为什么随机数Nonce是必要的](#为什么随机数Nonce是必要的)
2. [Schnorr签名实现Musig聚合签名](#Schnorr签名实现Musig聚合签名)
   + [聚合公钥](#聚合公钥)
      + [密钥取消攻击](#密钥取消攻击)
   + [聚合随机数](#聚合随机数)
   + [聚合签名](#聚合签名)
   + [Musig三轮通信的完整过程](#Musig三轮通信的完整过程)

## Schnorr签名

### 椭圆曲线中的加密方式

在了解Schnorr签名之前，要做的第一件事是基于椭圆曲线创建公、私钥对。椭圆曲线上的点可进行一些代数运算，涉及标量（scalar）和点（point）的概念。标量是正整数，由小写字母（例如k）表示，曲线上的一个点，用大写字母（例如A）或一对坐标表示（例如（x，y）），标量和点支持下图的运算。

![An overview of all operations of scalars and points over elliptic curves.](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626838499243-1626838499234.png)

​		由图我们可以看出，标量和点之间可以进行乘除运算，但点和点之间不满足乘除运算。针对这一点进行展开，如果现在有一个点G，G多次相加自身的结果为`R = G + G + G = 3 * G`，G和R可以视为加密前、后的点，3是标量（实际上是一个很大的数字）。若3和G是已知的，那么`R = 3 * G`就能很轻易地计算出来，但是如果只知道加密后的点R和加密前的点G，则无法通过`R / G`得到标量k=3，因为点无法满足该运算。上述情况类似于公、私钥对的生成情况，将标量k视为私钥，加密后点的纵坐标视为公钥，想逆向破解私钥k，唯一可行的就是猜测标量k为多少时 `k * G = R`，枚举k进行运算才能得到答案。在比特币中，通过SECP256K1曲线生成公、私钥对并进行签名，该标量的值是 0 到 2的256 次方之间的整数值，相当于整个宇宙的原子数量，所以有无穷无尽的可能性，由此保障了生成的公、私钥对的安全性。

​		一条椭圆曲线就是一组被![formula-a](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626849064158-1626849064158.png)定义的且满足![formula-b](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626849094992-1626849094991.png)的点集，不同的参数值对应不同的椭圆曲线。对每一个X轴的值，对应两个Y轴的值y 和 -y，这两个纵坐标的值只有一个满足对SECP256K1_FIELD_SIZE取模的结果为二次剩余，可以通过jacobi_symbol确定，这个有效的y值即为公钥。因此，能够从私钥d，无歧义地产生一个点`P = k*G`，获取其有效的y轴值作为公钥。

![](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626849644267-1626849644265.png)

​		上述的非对称性是Schnorr签名讨论的前提 。

### Schnorr签名的实现原理

![Schnorr Signatures And Verification](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626847754743-1626847754740.png)

对一则消息m进行Schnorr签名，首先需要定义几个变量：

- G：椭圆曲线
- m：待签名的数据，通常是一个32字节的哈希值
- d, P：用户持有的私钥d和公钥P，其中`P = d * G`
- H()：哈希函数
  - 如`H(m | R | P)`可理解为：将m, R, P三个字段拼接在一起然后再做哈希运算
- 另：x(R)表示点R的横坐标值

#### 对消息进行签名

创建Schnorr签名遵循以下方法：

+ 创建随机数k，从k创建随机点R，其中`R = k*G`
+ 计算标量`s = k + H(x(R)|P|m) * d`，其中P为公钥，d为私钥，m为消息
+ 最终得到Schnorr签名`S = （x(R), s）这一对值`，由32字节的x(R)和32字节的s拼接而成，最终长度为64位

![schnorr-code](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626854513363-1626854513358.png)

Schnorr签名结果如下：

```json
message = ab530a13e45914982b79f9b7e3fba994cfd1f3fb22f71cea1afbf02b460c6d1d
user privkey = 40811356790294382983149959962124660206130438370548668724053064036307538116679
user pubkey = 0374248e7fdb13546ac94d961365aff6d352c413dd79b2056a2bb60f2971e79fc6

nonce: 55221941004635623701832462325081428209726520449893387818054719258463597914212
nonce point: 039c5530a2e78faa9a87d12ea48f201cec4462e21237ee6e682c935a28a44b826d

R: 039c5530a2e78faa9a87d12ea48f201cec4462e21237ee6e682c935a28a44b826d
x(R) = 9c5530a2e78faa9a87d12ea48f201cec4462e21237ee6e682c935a28a44b826d
s: 2265af70948f333f49fd1f4d38b4791cb8682f05d9719e5f482ef99b7dff790d

Signature: 9c5530a2e78faa9a87d12ea48f201cec4462e21237ee6e682c935a28a44b826d2265af70948f333f49fd1f4d38b4791cb8682f05d9719e5f482ef99b7dff790d
```

#### 对签名进行验证

​		在不知道随机数k和私钥d的情况下，任何人还是可以对Schnorr签名进行验证。验证者已知的是G-椭圆曲线、H()-哈希函数、m-待签名消息、P-公钥、x(R)和s-Schnorr签名。验证等式：`S = R + H(x(R)|P|m) * P`若成立，则证明签名合法。

​		推演一下这个过程，过程包含了一个极其重要的理论：椭圆曲线中点与点无法进行除法运算。

1. `s = k + H(m | R | P) d`，等式两边都乘以椭圆曲线G，则有：

2. `s*G = k*G + H(m | R | P)*d*G`，又因`R = k*G, P = x*G`，则有：

3. `s*G = R + H(m | R | P)*P`，椭圆曲线无法进行除法运算，所以第3步的等式，无法向前反推出第1步，就不会暴露k值以及x私钥，同时，也完成了等式验证。

#### 为什么随机数Nonce是必要的

​		假设我们仅仅只是签署了一条消息 m，那么`h = H(P | m)`，得到标量`s = h * d`，因为没有随机数，所以得到32位的Schnorr签名`S = s = h*d`，对这个结果，计算`S = H(P | m) * P`是否成立，可以照常检验签名是否有效。

​		但是在这种情况下，任何人都能计算出私钥d是多少，因为s是标量，所以`d = s / h`很轻松地就能计算出来；若是加入随机数`k`,就必须求解`d = (s - k) / h`，但是随机数k是未知的，因此这个计算是不可行的，这也解释了为什么要引入随机数。

## Schnorr签名实现Musig

​		由于椭圆曲线上的点能线性累加，因此多个用户的随机数、公钥就能线性累加，生成聚合随机数、聚合公钥，相应的，一个“聚合账户”的概念就产生了，用这个“聚合账户”完成上述的Schnorr签名过程，和普通的账户进行Schnorr签名的流程是基本一致的。因此，比特币主网引入Schnorr签名后，聚合签名跟普通的交易就交易结果上来看，是看不出区别的，这也在很大程度上保护了参与聚合签名的用户的隐私。

​		Musig方案包括两个部分，聚合公钥和聚合随机数、签名。聚合公钥的过程线下进行不需要通信，聚合随机数、签名的过程需要三轮通信（在Musig2方案下，改良到两轮通信，参阅上篇文章）。

![musig-overview](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626919916096-image-20210721163826794.png)

### 聚合公钥

​		聚合公钥就是线性相加每一个参与者的公钥，这个过程很容易完成，即`P_agg = P_0 + P_1 + ... + P_n`，但是需要考虑密钥取消攻击。

#### 密钥取消攻击

​		可以想象这样一个场景，Alice和Bob想要生成2-2的聚合签名，为了达到聚合的目的，需要交换上述Schnorr签名所需要的公钥和随机数，但是如果Bob事先知道Alice的公钥`P_a`和随机数`R_a`, 那么Bob就可以欺骗Alice，将`P'_b = P_b - P_a` 和 `R'_f = R_b - R_a`发送给Alice，当Alice计算签名时候，会发生下面的情况。

![key cancellation](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626919973621-image-20210721171442302.png)

​		从结果可见，Alice的`R_a`和`P_a`在最终的签名结果中被抵消了，这就意味着Bob能独自控制这笔聚合签名的资产，这对Alice来是显然是危险的。

当然我们可以通过挑战Bob，让Bob证明他拥有所声明的公钥P和随机数R的私钥标量，但是这需要多一轮通信，因此可以采取添加挑战因子的方式调整参与者公钥，抵消密钥取消攻击，具体做法如下：

​		每个参与者的公钥（Pubkey）都是由挑战因子调整的，挑战因子对每个参与者来说都是独一无二的，所有挑战因子都基于参与者们的聚合公钥产生，这样做可确保没有个人参与者（或参与者组）能够创建一个抵消其他参与者的公钥的公钥。 只要每个人都可以获得所有参与者公钥（通过线下沟通、协调等方式），那么就可以在本地计算挑战因子和聚合公共关键，不需要增加一轮通信。

![image-20210721172330638](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626920000310-image-20210721172330638.png)

### 聚合随机数

​		每个参与者都要生成自己的随机数`k_i`和随机数点`R_i`（i = 0,1...，表示参与者序号），然后，参与者交换这些随机数点`R_i`，并且将所有随机数点`R_i`线性相加得到聚合随机数点``R_agg`。这个过程和上述的聚合公钥很相似，但无法向聚合公钥一样采取挑战因子的方式进行安全验证，因为参与者的公钥是不变的，即使多次进行多重签名，经过线下协调，最终的聚合公钥还是一致的；但是随机数不一样，每一次签名过程的随机数都各不相同，为了避免交换过程的欺骗行为，不可避免地需要增加一轮通信，参与者在这一轮通信中交换随机数点`R_i`的哈希承诺。

​		每个参与者在收到所有随机数点`R_i`的承诺后，才会交换随机数点`R_i`，并验证随机数点`R_i`和给定的哈希承诺是否相符，如果

都确认无误就会计算：符合模SECP256k1_FIELD_SIZE为二次剩余的有效聚合随机数`R_agg`。

![agg-nonces](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626920030312-image-20210721180219390.png)

### 聚合签名

​		在每个参与者都计算出聚合公钥和聚合随机数后，就可以进行签名计算了。每个参与者拥有私钥``d_i`和随机数`k_i`，计算标量 `s_i = k_i + H(x(R_agg) | P_agg | m) * d_i`得到的结果为部分签名，最后交换签名结果，并线性相加每个参与者的部分签名生成最终的聚合签名。

![agg-sigs](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626920048629-image-20210721180434124.png)

### Musig三轮通信的完整过程

![musig1](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626864110199-1626864110196.png)

![musig2](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626864178031-1626864178028.png)

![musig3](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1626920629707-image-20210721184333777.png)

结果如下：

```json
每个参与者的公钥为:
	026c5d5e73124f3c821c0985df787e11b3d018a86add577fa8661613a0d49dde59, 
	03f771877964fa2ce401d87bc2558a0df1e6921acef99389f059712b32cfda35fd, 
	03f039fdcdb728efbbddf4ee452419a988497debb7bd1b42644c5fa66e9af8c8b6.

聚合的公钥为：02eeeea7d79f3ecde08d2a3c59f40eb3adcac9defb77d3b92053e5df95165139cd

调整后的 公钥1 is 02066483b0841dba5821ee719178fb878102262cf505975e0a2d18e48c84b8362e
调整后的 公钥2 is 0376e2769bcdc42a20e18cfa83125435c0cd1348a7849c6feebeb9394776cdcea6
调整后的 公钥3 is 03bbc4110f3b28023f6ffefd29de76fe915029ce693f8fc3a1c327bdeb73940840
每个参与者的随机数标量为:
	115792089237316195423570985008687907852837564279074904382605163141518161494236, 
	115792089237316195423570985008687907852837564279074904382605163141518161494115, 
	115792089237316195423570985008687907852837564279074904382605163141518161494004.

聚合的随机数为: 03f90c3416d74049bf27b5563067c58401ff466e4bb04e1fa4d51ae4c93b4a8316

部分签名为:
	65632340538892058604021005685526525791383877758802541334726676556343496273695
	49071424722101348040708779394444974474178306070453713897027096230295229616215
	40052638870461774859002446004708555184684360378078494722527781424448839071327

聚合签名为:
	f90c3416d74049bf27b5563067c58401ff466e4bb04e1fa4d51ae4c93b4a83165625054ca06a0e7a76ecca379955370d56fa014fc1c0e62313dd4ed246b23494
```

