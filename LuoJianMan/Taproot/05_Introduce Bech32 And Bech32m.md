# Introduce Bech32 And Bech32m

## Contents

2. [A Quick Understanding of Bech32](#A%20Quick%20Understanding%20of%20Bech32r)
   + [Generate Bech32 Address](#Generate%20Bech32%20Address)
3. [What Is Bech32m](#What%20Is%20Bech32m)
   + [Bech32m](#Bech32m)
4. [Summary](#Summary)

## A Quick Understanding of Bech32

`Segregated Witnessing` (SegWit) is a Bitcoin protocol update that occurred in August 2017, SegWit effectively separates or isolates signature data or witness data from Bitcoin transactions, and in doing so allows Bitcoin blocks to accommodate more transactions, thereby increasing the scalability of the Bitcoin network. In addition, separating signature data from bitcoin transactions provides opportunities for Layer 2 scalability solutions (Layer 2), such as the Lightning Network. 

`Bech32` is a Bitcoin address that is fully compatible with SegWit. Many people refer to Bech32 addresses as `bc1` addresses because their address strings always start with `bc1`. Bech32 was applied as part of the Bitcoin Improvement Proposal (BIP-173), where Bitcoin used base58 addresses and truncated double SHA256 checksums before.

However, this implementation has some drawbacks, as it uses mixed upper and lower case letters, making base58 addresses difficult to enter and prone to typing errors when sending bitcoins. Imagine trying to type `1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2` correctly without copying and pasting, and finding it a difficult task. In addition, base58 addresses require a lot of storage space to represent in 2D codes and are relatively complex and slow to decode. Combine all of these issues with the long time required for a double SHA256 checksum and it begins to make sense why the switch is needed.

### Generate Bech32 Address

The Bech32 address is created from the public key, as follows:

1. Perform SHA-256 hash operation on a compressed public key (0x02 or 0x03 followed by 32 bytes of X coordinate value): `0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798` to get `0f715baf5d4c2ed329785cef29e562f73488c8a2bb9dbc5700b361d54b`.

2. Then RIPEMD-160 hash the hash result: `751e76e8199196d454941c45d1b3a323f1433bd6`.

3. The result of step 2 is an array of 8-bit unsigned integers (cardinality 2 ^ 8 = 256), which is converted by Bech32 coding to a 5-bit unsigned integer array (radix 2 ^ 5 = 32), so we "squeeze" the bytes to get, such as calling the following function`convertbits('751e76e8199196d454941c45d1b3a323f1433bd6', 8, 5)`.

    ```python
    def convertbits(data, frombits, tobits, pad=True):
        """General power-of-2 base conversion."""
        acc = 0
        bits = 0
        ret = []
        maxv = (1 << tobits) - 1
        max_acc = (1 << (frombits + tobits - 1)) - 1
        for value in data:
            if value < 0 or (value >> frombits):
                return None
            acc = ((acc << frombits) | value) & max_acc
            bits += frombits
            while bits >= tobits:
                bits -= tobits
                ret.append((acc >> bits) & maxv)
        if pad:
            if bits:
                ret.append((acc << (tobits - bits)) & maxv)
        elif bits >= frombits or ((acc << (tobits - bits)) & maxv):
            return None
        return ret
    ```

4. Get an array of 5-bit unsigned integers `01110 10100 01111 00111 01101 11010 00000 11001 10010 00110 01011 01101 01000 10101 00100 10100 00011 10001 00010 11101 00011 0101 00011 00100 011100 0110 01110 110`, the hexadecimal representation is `0e140f070d1a001912060b0d08150414031021d030c1d03040f1814060`, the hexadecimal representation is `0e140f070d1a001912060b0d081504140311021d030c1d03040f1814060`.

5. Add the isolated witness version number (Segwitness version) byte to the result (the current version is 0) to get `000e140f070d1a001912060b0d08150414031021d030c1d03040f1814060e1e16`.

6. Use the data obtained from the previous step and HRP (the main network is bc, the test network is tb), calculate the checksum `0c0709110b15`, add it to the previous result, and get `000e140f070d1a001912060b0d08150414031021d030c1d03040f1814060e1e160c0709110b15`.

7. Map each value to the character set of Bech32 (qpzry9x8gf2tvdw0s3jn54khce6mua7l, such as 00-> Q, 0e-> wpenny...) to get qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4.

    + ![bech32-charset](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1628674702208-1628674702206.png)

8. Finally get a Bech32 encoded addressï¼Œ`bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4`

Among them, the bech32 address has four components:

1. Human readable part `HRP`.
2. The number `1` is used as a separator.
3. Base32 encoded string containing valid address data.
4. The 6-character base-32 coding error correction code generated by BCH algorithm coding

Supporting Bech32 reduces the probability of errors in sending and receiving bitcoins, because Bech32 addresses are in full lowercase rather than mixed case, making it easier for users to share and enter them. If the user does make an error when entering the address, the Bech32 address also allows you to identify which characters may be incorrect.

## What Is Bech32m

BIP173 defines the universal checksum base 32 encoding format of `Bech32`, which is used for isolated witness output of version 0 (P2WPKH and P2WSH) and other applications. However, Bech32 has an unexpected defect: as long as the last character is `p`, inserting or deleting any number of `q` characters before it will not invalidate the checksum. Due to the limitations on two specific lengths, this does not affect the existing use of SegWit version 0 addresses, but may affect future uses of Bech32 encoding, and other applications that use bech32 addresses may also be affected.

`Bech32m` is an optimized variant of Bech32, which alleviates this insertion defect and related problems, and modifies BIP173 to use Bech32m for native isolation witness output of version 1 and later, while Bech32 is still used for isolation witness output of version 0.

### Bech32m

Bech32m modifies the checksum of the Bech32 specification and replaces the constant `1` in the final XOR checksum with `0x2bc830a3`.

```python
BECH32M_CONST = 0x2bc830a3

def bech32m_polymod(values):
  GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]
  chk = 1
  for v in values:
    b = (chk >> 25)
    chk = (chk & 0x1ffffff) << 5 ^ v
    for i in range(5):
      chk ^= GEN[i] if ((b >> i) & 1) else 0
      # k(x) = {29}x^5 + {22}x^4 + {20}x^3 + {21}x^2 + {29}x + {18}
      # {2}k(x) = {19}x^5 +  {5}x^4 +     x^3 +  {3}x^2 + {19}x + {13}
      # {4}k(x) = {15}x^5 + {10}x^4 +  {2}x^3 +  {6}x^2 + {15}x + {26}
      # {8}k(x) = {30}x^5 + {20}x^4 +  {4}x^3 + {12}x^2 + {30}x + {29}
      # {16}k(x) = {21}x^5 +     x^4 +  {8}x^3 + {24}x^2 + {21}x + {19}
  return chk

def bech32m_hrp_expand(s):
  return [ord(x) >> 5 for x in s] + [0] + [ord(x) & 31 for x in s]

def bech32m_verify_checksum(hrp, data):
  return bech32m_polymod(bech32m_hrp_expand(hrp) + data) == BECH32M_CONST

def bech32m_create_checksum(hrp, data):
  values = bech32m_hrp_expand(hrp) + data
  polymod = bech32m_polymod(values + [0,0,0,0,0,0]) ^ BECH32M_CONST
  return [(polymod >> 5 * (5 - i)) & 31 for i in range(6)]
```

All other aspects of Bech32 remain the same, including its human readable part (HRP), and you can write the following code to decode the combined functions of Bech32 and Bech32m at the same time. It returns None to indicate a failure, or one of the BECH32 / BECH32M enumerated values to indicate decoding according to the appropriate standard.

```python
class Encoding(Enum):
    BECH32 = 1
    BECH32M = 2

def bech32_bech32m_verify_checksum(hrp, data):
    check = bech32_polymod(bech32_hrp_expand(hrp) + data)
    if check == 1:
        return Encoding.BECH32
    elif check == BECH32M_CONST:
        return Encoding.BECH32M
    else:
        return None
```

The SegWit version 0 output (especially the P2WPKH and P2WSH addresses) will continue to use the Bech32 specified in BIP173, and the isolated witness output addresses from versions 1 to 16 will use Bech32m. Again, all other aspects of the coding remain the same, including `bc` (HRP). To decode bitcoin network addresses, client software should use Bech32 and Bech32m decoders to decode, or use decoders that support both. In both cases, the address decoder must verify that the encoding matches the decoded isolated witness version (version 0 is Bech32, the other version is Bech32m). Such as the following checks.

```python
def decode(hrp, addr):
    hrpgot, data, spec = bech32_decode(addr)
    if hrpgot != hrp:
        return (None, None)
    decoded = convertbits(data[1:], 5, 8, False)
    # Witness programs are between 2 and 40 bytes in length.
    if decoded is None or len(decoded) < 2 or len(decoded) > 40:
        return (None, None)
    # Witness versions are in range 0..16.
    if data[0] > 16:
        return (None, None)
    # Witness v0 programs must be exactly length 20 or 32.
    if data[0] == 0 and len(decoded) != 20 and len(decoded) != 32:
        return (None, None)
    # Witness v0 uses Bech32; v1 through v16 use Bech32m.
    if data[0] == 0 and spec != Encoding.BECH32 or data[0] != 0 and spec != Encoding.BECH32M:
        return (None, None)
    # Success.
    return (data[0], decoded)
```

## Summary

Bech32m eliminates this vulnerability by changing the constants used in the Bech32 encoding scheme, making it more secure. Bech32m is proposed as a coding scheme for SegWit version 1 (Taproot) addresses, which will be introduced by Taproot upgrades. After introduction, when the address is generated for the isolated witness output, if its witness version is 0, it is encoded using Bech32; if its witness version is 1 or higher, it is encoded using Bech32m.

