# Schnorr盲签名

## 大纲

1. [Schnorr盲签名方案](#Schnorr盲签名方案)
2. [Schnorr盲签名是如何工作的](#Schnorr盲签名是如何工作的)
3. [Schnorr盲签名的安全性](#Schnorr盲签名的安全性)
4. [盲CoinSwap服务器](#盲CoinSwap服务器)

## Schnorr盲签名方案

顾名思义，Schnorr 盲签名是签名者不知道他们签署了什么的签名。 可能很难想象这有什么用处，但在处理`不经意服务器（Oblivious Server）`时，它是一个很好的工具，而这在比特币和整个互联网的未来发挥着重要作用。

`不经意服务器`指的是一些支持可信计算或数据存储的服务器，用户可能会对其服务进行付费，但服务器却不需要知道它操作的所有信息，这类信息包括用户的身份、哪些方正在相互交互、正在存储哪些数据、正在执行的什么计算等等内容，因为这个过程是不经意的。一个不经意的服务器应该是一个可靠的计算服务，除了计算什么都不做。

将这个场景迁移到比特币网络中，如果采用盲签名，节点只负责运算，而无法知晓正在计算的内容是什么，最终节点打包的区块并不会透露用户的任何隐私，这为用户的匿名性提供了极大保护。用户只需为节点（矿工）支付交易的手续费，就能享受比特币网络提供的隐私性和安全性。

Schnorr盲签名方案有四个步骤：

+ 签名者提供一个随机数

+ 接收者提出一个使用随机数构造的盲挑战（它不显示有关签名内容的信息）

+ 签名者使用步骤 1 中的随机数提供此挑战的正常 schnorr 签名

+ 接收者解开这个签名的盲部分，从而产生一个正常的、有效的 Schnorr 签名，它看起来与签名者提供的签名完全无关，因为 R 和 s 值都由随机数调整。

## Schnorr盲签名是如何工作的

在创建盲签名的过程中，具有公钥 `X` 的签名者和接收者之间的通信类似于Schnorr 的签名协议：

1. 签名者生成一个随机的 `k` 并将随机数 `R = k*G` 发送给接收者。
2. 接收者响应一个挑战 `c`。
3. 签名者回复生成的盲签名 `s = k + c*x`，其中 `x` 是签名者的私钥。

在正常的 Schnorr 协议中，接收者旨在选择 c 作为他们想要签名的某些消息 m 的哈希 `H(X, R, m)`。 但是我们使用盲签名的目标是允许接收者以某种方式调整 R 和 s 以获得签名 `(R', s')`，其中调整值是随机数，因此该签名看起来与原始的 `(R, s)` 完全无关。

​		因此，如果我们想完成这个方案，最直接的做法就是让接收者生成随机数 `α`和`t`，并让 `X' = X + t*G`, `R' = R + α*G`， X'和R'是调整后的公钥和随机数。因此它们生成的挑战将是 `c = H(X', R', m)`，生成的盲签名为 `s = k + H(X',R',m) * x` ，然后需要调整为有效 schnorr 签名。

![s'](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1629345358465-1629345358463.png)

这样，我们就最终得到了使用密钥 X'签署的消息 m 的有效 Schnorr 签名 `(R',s')`。

然而，这个方案有一个致命的缺陷。 如果签名者试图查看它已签署的内容（例如通过查看比特币交易的所有签名）并且遇到使用公钥 X' 签署消息 m得到的签名 (R', s') ，它将无法识别这些值中的任何一个，这看似达到了匿名的目的 ，但它将能够计算 H(X', R', m) 并将该值与它在步骤 2 中收到的挑战进行比较，这破坏了签名者的匿名性。

为了解决这个问题，可以生成一个新的随机数`β` ，并用它来调整挑战 `c = H(X', R', m) + β`，调整后的签名就变成了

![s''](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1629352879562-1629352879560.png)

并且，我们必须对随机数添加额外的调整以保持一致，调整后得到 `R'=R + α∗G + β∗X`。现在得到最终的盲签名 `(R', s')`，其中所有这些值对于签名者来说都是随机的，并且挑战哈希也是随机的。

## Schnorr盲签名的安全性

Schnorr 盲签名方案对于所提出的各种攻击来说，实际上并不安全，只是规定签名者在很小一段时间内中止和重试，才能确保使其安全（但也会导致不太有效的签名方案）。正因为如此，通常只有在需要Schnorr签名时使用 Schnorr 盲签名才是有意义的（例如，如果被签名的事物是未来的比特币交易）。对于盲签名的大多数链下用例，使用其他盲签名方案可能更有意义。 如BIP340提及的，确切地说，Schnorr 签名承诺了一个非常简单的盲签名方案，但它是不安全的，因为它容易受到 Wagner 的攻击。一种已知的缓解措施是让签名者以一定的概率中止签名会话，并且可以在非标准密码假设下证明由此产生的方案是安全的。

## 盲CoinSwap服务器

盲签名的一个有趣用例是 CoinSwap 服务器，CoinSwap 是一对不可链接的交易，通常有两方以原子方式相互支付几乎相等的金额。使用盲签名，可以有一个盲 CoinSwap 服务，用户可以支付少量费用与服务器执行 CoinSwap，而服务器无法跟踪哪个付款对应哪个收款。

就像常规 Schnorr 签名一样，盲签名支持预先提交的随机数方案。具体来说，一旦服务器给出了它的随机数，并且客户端生成了它的调整，客户端就能够计算 `s*G`，其中 s 来自已知消息的盲签名，这可以实现这些签名的原子购买，这是通过使用 `s*G` 作为适配器签名中的适配器点来实现的。该签名将用户的付款签署给服务器，通过声明此付款的原子性，服务器向用户显示 `s`，然后用户可以解开签名的盲部分并使用它来声明从服务器到客户端的付款（在等待一段时间以增加他们的匿名集之后）。这样，假设与服务器的所有通信都是匿名完成的（使用 TOR、Lightning 或其他类似机制），服务器将无法链接其传入和传出的交易，同时为用户提供有价值的 CoinSwap。