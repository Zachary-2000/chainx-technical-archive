# Schnorr Applications: Blind Signatures

## Content

1. [Schnorr blind signature scheme](#Schnorr%20blind%20signature%20scheme)
2. [How does Schnorr blind signature work](#How%20does%20Schnorr%20blind%20signature%20work)
3. [Security of Schnorr Blind signature](#Security%20of%20Schnorr%20Blind%20signature)
4. [Blind CoinSwap Servers](#Blind%20CoinSwap%20Servers)

## Schnorr blind signature scheme

As the name suggests, a Schnorr blind signature is a signature where the signer does not know what they are signing. It may be hard to imagine what use this would be, but it's a great tool for dealing with Oblivious Server, which is playing an important role in the future of Bitcoin and the Internet as a whole.

` Oblivious Server ` refers to some support of trusted computing and data storage server, the user may be paid for their services, but the server does not need to know its operation of all information, this information includes the user's identity, which are interact with each other, which is stored data, executing what calculation and so on the content, because the process is casual. A oblivious server should be a reliable computing service that does nothing but compute.

Migrating this scenario to the Bitcoin network, if the blind signature is used, the node is only responsible for the calculation, but has no idea what is being calculated. The final block packed by the node does not reveal any privacy to the user, which provides great protection for the user's anonymity. Users can enjoy the privacy and security provided by the Bitcoin network by paying a transaction fee for the node (the miner).

The Schnorr blind signature scheme has four steps:

+ The signer provides a random number

+ The receiver presents a blind challenge using a random number construct (it does not display information about the content of the signature)

+ The signer provides a normal Schnorr signature for this challenge using the random number in Step 1

+ The receiver undoes the blind part of the signature, resulting in a normal, valid Schnorr signature that appears to be completely independent of the signature provided by the signer, since both R and S values are adjusted by random numbers.

## How does Schnorr blind signature work

In the process of creating a blind signature, the communication between the signer and the receiver with the public key `X` is similar to Schnorr's signature protocol:

1. The signer generates a random `k` and sends the random number `R = k* G` to the receiver.
2. The recipient responds to a challenge `c`.
3. The signer replies to the generated blind signature `s = k + c * x`, where `x` is the signer's private key.

In a normal Schnorr protocol, the receiver aims to select c as the hash `H (X, R, m) `of some of the messages they want to sign. However, the goal of using a blind signature is to allow the receiver to adjust R and s in some way to obtain the signature `(R, s)`, where the adjustment value is a random number, so the signature seems to have nothing to do with the original `(R, s)`.

Therefore, if we want to complete this solution, the most direct way is to let the receiver generate random numbers `α `and `t`, and let `X' = X + t* G`, `R' = R + α * G`, X' and R' are adjusted public keys and random numbers. Therefore, the challenge generated by them will be `c = H(X', R', m)`, and the generated blind signature is `s = k + H(X',R',m) * x`, and then it needs to be adjusted to a valid schnorr signature.

![s'](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1629345358465-1629345358463.png)

In this way, we finally get a valid Schnorr signature of message m signed with key X'.

However, this scheme has a fatal flaw. If the signer tries to view what it has signed (for example, by looking at all the signatures of bitcoin transactions) and encounters a signature` (R', s')` obtained with the public key X' signature message m, it will not be able to recognize any of these values, which seems to achieve the purpose of anonymity. But it will be able to calculate `H (X', R', m)` and compare this value with the challenge it received in step 2, which undermines the anonymity of the signer.

To solve this problem, you can generate a new random number `β `and use it to adjust the challenge `c = H (X', R', m) + β`, and the adjusted signature becomes

![s''](https://cdn.jsdelivr.net/gh/rjman-ljm/resources@master/assets/1629352879562-1629352879560.png)

Also, we have to add additional adjustments to random numbers to keep them consistent, and we get `R'=R + α∗G + β∗X` after adjustment. Now you get the final blind signature `(R', s')`, where all these values are random for the signer, and the challenge hash is also random.

## Security of Schnorr Blind signature

The Schnorr blind signature scheme is actually not secure for all kinds of attacks proposed. It only requires the signer to abort and retry in a very short period of time to ensure its security (but it will also lead to less effective signature schemes). Because of this, it usually makes sense to use Schnorr blind signatures only when Schnorr signatures are needed (for example, if the thing being signed is a future bitcoin transaction). For most out-of-chain use cases of blind signatures, it may make more sense to use other blind signature schemes. As BIP340 mentioned, to be exact, Schnorr signature promises a very simple blind signature scheme, but it is not secure because it is vulnerable to Wagner attacks. A known mitigation measure is to allow the signer to terminate the signature session with a certain probability, and the resulting scheme can be proved to be secure under the non-standard password assumption.

## Blind CoinSwap Servers

An interesting use case for blind signatures is the CoinSwap server, where CoinSwap is a pair of unlinkable transactions, usually with two parties paying almost the same amount to each other in an atomic way. With blind signatures, there can be a blind CoinSwap service where the user can pay a small fee to perform CoinSwap with the server, and the server cannot track which payment corresponds to which collection.

Like regular Schnorr signatures, blind signatures support pre-submitted random number schemes. Specifically, once the server gives its random number and the client generates its adjustment, the client can calculate `s* G`, where s comes from the blind signature of the known message, which can realize the atomic purchase of these signatures. This is achieved by using `s*G` as the adapter point in the adapter signature. The signature signs the user's payment to the server, and by declaring the atomicity of the payment, the server displays `s` to the user, and then the user can unlock the blind part of the signature and use it to declare the payment from the server to the client (after waiting for a period of time to increase their anonymous set). In this way, assuming that all communication with the server is done anonymously (using TOR, Lightning, or other similar mechanism), the server will not be able to link its incoming and outgoing transactions while providing users with valuable CoinSwap.