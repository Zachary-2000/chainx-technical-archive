# Schnorr threshold signatures: FROST

## Introduce

FROST (Flexible Round-Optimized Schnorr Threshold Signatures) is a flexible round-optimized Schnorr threshold signing scheme that reduces the network overhead in the signing operation while improving the state of the art of the Schnorr threshold signing protocol because it can safely perform the signing operation in a single round perform the signing operation securely without limiting the concurrency of the signing operation, yet allowing true threshold signatures, so that the signing operation requires only a threshold number of participants.

FROST can either be used as a two-round protocol where the signer sends and receives a total of two messages, or it can be optimized as a (non-broadcast) single-round signing protocol with a preprocessing phase.FROST achieves efficiency gains without the optimistic case of participant misbehavior. Because the preprocessing round can be performed separately from the signing round, the signing operation can be performed asynchronously; once the preprocessing round is completed, the signer only needs to receive and eventually reply to a message to create a signature.

FROST achieves its efficiency improvement in part by allowing the protocol to abort in the presence of a misbehaving participant (who is then identified and excluded from future operations) - a reasonable model for practical deployment scenarios. During the course of the protocol, if a misbehaving participant provides malformed values, honest parties can identify and exclude the misbehaving participant and re-run the protocol. the flexible design of FROST allows it to support many practical use cases of threshold signatures. In addition, while some threshold schemes require all participants to be active during the signature operation and refer to the threshold property of the protocol as simply a security property, FROST allows any threshold number of participants to generate valid signatures. Thus, FROST can support use cases where a subset of participants (or participating devices) can remain offline, a property that is often required for security in practice.

## Background

### Threshold Signature Scheme

A threshold signature scheme is a cryptographic fundamental used to facilitate common ownership of a private key by a group of participants such that a threshold number of participants must cooperate in issuing a signature that can be verified by a single public key. Threshold signatures are useful in a range of situations where a distributed root of trust needs to be established between a set of equally trusted parties. Similar to signature operations in a single-party environment, some implementations of threshold signature schemes need to perform signature operations at large scale and under heavy load. For example, threshold signatures can be used by a group of signers to verify financial transactions in cryptocurrencies, or to sign a network consensus generated by a group of trusted institutions. In both examples, as the number of signatories or signing operations increases, the number of communication rounds required between participants to generate a joint signature becomes a performance bottleneck, in addition to the increased load experienced by each signer. This problem is further exacerbated when signers utilize network-limited devices or unreliable networks for transmission, or when protocols are desired that allow signers to participate in signature operations asynchronously. Therefore, optimizing the network overhead of the signature operation is highly beneficial for practical applications of threshold signatures.

### Shamir key sharing

Many threshold schemes are built on Shamir secret sharing, a (t,n) threshold signature scheme that relies on Lagrangian interpolation to recover secrets. In Shamir secret sharing, a trusted central dealer distributes a secret s to n participants in such a way that any cooperative subset of t participants can recover the secret. To distribute this secret, the dealer first randomly chooses t-1 coefficients a1,... , at-1, and uses the randomly chosen values as coefficients to define a polynomial of degree t-1 f (x) = s + SUM (ai xi, i = 1... . t-1), where f (0) = s. Subsequently, the secret share of each participant Pi is (i, f (i)), and the dealer is trusted to honestly assign to each participant P1,... , Pn. , Pn. To reconstruct the secret, at least t participants perform Lagrangian interpolation to reconstruct the polynomial and thus find the value s = f(0). However, groups with fewer than t participants cannot reconstruct the secret because at least t points are needed to reconstruct the polynomial of degree t-1.

### Feldman's Verifiable Key Sharing

Feldman's Verifiable Secret Sharing (VSS) scheme builds on Shamir's secret sharing by adding a verification step to prove the consistency of a participant's share with a public promise that is considered to be correctly visible to all participants. To validate the formation of a share, each participant uses this promise to verify their share. If the validation fails, the participant can issue a complaint against the distributor and take an action such as broadcasting this complaint to all other participants.FROST also uses this same technique. The promises generated in Feldman's scheme are as follows. As in the previous Shamir secret sharing, the dealer samples t-1 random values (a1,... , at-1) are sampled and these values are used as coefficients to define a polynomial fi of degree t-1 such that f(0) = s. However, while distributing a private share (i, f(i)) to each participant Pi , the dealer also distributes a public commitment C = < A0, ... , At-1 >, where A0 = gs and Aj = g^{aj}.
Note that in the distributed setup, each participant Pi must ensure that it has the same view of C as all other participants. In practice, implementers ensure the consistency of participants' views by using techniques such as publishing commitments to a centralized server that is trusted to provide a single view to all participants, or adding another protocol round in which participants compare the values of commitments they receive to ensure that they are the same.

### Distributed Key Generation

Unlike threshold schemes such as Shamir secret sharing, which rely on trusted dealers, Distributed Key Generation (DKG) ensures that each participant contributes equally to the generation of shared secrets. At the end of the protocol run, all participants share a joint public key Y, but each participant holds only a share of the corresponding secret, so that no group of participants smaller than the threshold knows about it. Distributed key generation (DKG) supports this threat model by making each participant contribute equally to the generation of the shared secret. At the end of the protocol run, all participants share a joint public key Y, but each participant holds only a share si of the corresponding secret s, such that no set of participants smaller than the threshold knows s.

### Schnorr Signature

Typically, signatures generated by a threshold signature operation should ideally be indistinguishable from those generated by individual participants, thereby maintaining backward compatibility with existing systems and preventing privacy breaches of individual signers' identities. Signatures generated by the FROST signature operation are indistinguishable from Schnorr signatures and can therefore be verified using the standard Schnorr verification operation. For this purpose, we now describe the Schnorr signature and verification operations in the single-signer setup [Sch89].

Schnorr signature generation :

![Schnorr Sign](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1629185011893-1629185011890.png)

The first step generates a random number k, and then uses k to generate a random point R

The second step generates challenge c by hashing random point R and public key Y and message m

The third step uses the private key s to calculate z by k+s*c

The fourth step combines R and z to generate a signature

Schnorr signature verification:

![Schnorr Verify](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1629185037156-1629185037154.png)

The first step resolves R and z from the signature, and then calculates c

The second step calculates R' from Z = R + Y*c, and Z is the point generated by z

The third step determines whether the computed R' is consistent with the parsed R

### Additive Secret Sharing

Similar to the single signature described above, FROST requires the generation of a random number k for each signature operation. however, in the threshold signature, it is supposed that each participant is involved in the generation of k, but does not know its result. Although Shamir secret sharing and its derived structure require sharing on the secret polynomial f, where f(0)=s, the additive secret sharing scheme allows t participants to jointly compute a shared secret s, with each participant Pi contributing a value si, such that the resulting shared secret is s=SUM(si, i=1.. . t), i.e., the sum of each participant's shares. Thus, this t-out-of-t secret sharing can be done non-interactively; each participant directly chooses its own si. where si is the additive secret sharing of s. Then s is the sum of si, and then (si)/(Li) is the Shamir secret sharing of the same s, where Li is the Lagrange factor. In FROST, participants use this technique non-interactively in the signature operation to generate a one-time secret nonce which is the Shamir secret shared among all t signature participants.

## FROST

We now describe the FROST protocol, a flexible round-optimized Schnorr threshold signature scheme that minimizes the network overhead of generating Schnorr signatures in the threshold setting while allowing unrestricted parallelism of signature operations and a threshold number of signature participants.

### Key Generation

Round 1:

1. Each participant Pi draws t random values (ai0, . , ai(t-1))) <-$-Zq and uses these values as coefficients to define a polynomial fi(x) = SUM(aij xj, j=0.. .t-1).

2. Each Pi computes a proof of knowledge corresponding to the secret ai0 by using ai0 as the key to compute the Schnorr signature SIGi = (wi, ci) such that k <-$- Zq, Ri = gk, ci = H(i, CTX, g^{ai0}, Ri), wi = k + ai0* ci, where CTX is the context string to prevent replay attacks.

3. each participant Pi computes a public commitment Ci = < Ai0, . , Ai(t-1) >, where Aij = g^{aij}, 0 <= j <= t-1

4. Each Pi broadcasts Ci, SIGi to all other participants.
5. After receiving Cp, SIGi from participant 1 <= p <= n, p ! = i for Cp, SIGp, participant Pi verifies SIGp = (wp, cp) and terminates on failure, checking: cp =? = H(p, CTX, Ap0, g^{wp} * Ap0^{ cp})

Round2：

1. Each Pi securely sends a secret share (p, fi(p)) to the other participants Pp and keeps (i, fi(i)) for itself.

2. Each Pi sends a secret share to the other Pi by computing: g^{fp(i)} =? = PROD(Apk(i^k mod q),k=0.. .t-1) to verify their shares and abort if the check fails.

3. Each Pi calculates their share by computing si = SUM(fp(i), p=1... . n) to compute their long-standing private signature shares and store si securely.

4. Each Pi computes their public verification share Yi = g^{si} and the group's public key Y = PROD(Aj0, j=1... .n). Any participant can compute the public key by computing Yi = PROD( (Ajk)(i^k mod q), j=1... .n, k=0... .t-1) to calculate the publicly verified share of any other participant.

### Preprocess

![Preprocess](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1629266283474-1629266283472.png)

1.Create an empty list Li. then, for 1 <= j <= Q, do the following：

	- The single-use nonces sample (dij, eij) <-$- Zq* x Zq*
	- Derive the commitment shares (Dij, Eij) = (g^{dij}^, g^{eij}^)
	- Append (Dij, Eij) to Li. store ((dij, Dij), (eij, Eij)) for later use in signature operations

2.Publish (i, Li) to a predefined location, specified by the implementer.

### Sign

![Sign](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1629266327342-1629266327338.png)

Let SA denote the signature aggregator (who himself can be one of the t signature participants), S be the set of participants selected for this signature operation, B = < (i, Dij, Eij) for i in S> denote the ordered list of participant indexes corresponding to each participant Pi, and Li be the set of available commitment values for Pi announced in the preprocessing phase. Each identifier i is coupled to the jth commitment (Dij, Eij) published by Pi that will be used for this particular signature operation. Let H1, H2 be hash functions whose outputs are in Zq*.

1. SA first obtains the next available commitment from Li for each participant Pi in S and constructs B. 2.

2. For each i in S, SA sends a tuple (m, B) to Pi.

3. After receiving (m, B), each Pi first verifies the message m and then checks Dp j, Ep j in G* for each commitment in B. If either check fails, it aborts.

4. Then, each Pi computes the set of bound values rp = H1(p, m, B), p in S. Each Pi then derives the set of commitments R = PROD(Dpj * (Epj)^{rp}, p in S), and the challenge c = H2(m, R).

5. Each Pi computes their response by computing zi = dij + (eij * ri) + Li * si * c, using their long-term secret shared si, and using S to determine Li.

6. Each Pi safely removes ((dij, Dij),(eij, Eij)) from their local storage and returns zi to SA.

7. The signature aggregator SA performs the following steps：

	- Derive ri = H1(i,m,B), Ri = Dij * (Eij)^{ri} for i in S, followed by R = PROD(Ri, i in S), c = H2(m,R)
	- by checking that g^{zi} = ? = Ri * {Yi}^{c * Li} for each signature sharing zi, i in S to verify the validity of each response. If not equal, first identify and report misbehaving participants and then abort. Otherwise, continue
	- Compute the response of the group z = SUM(zi, i in S)
	- Publish the signature SIG = (z, c) with the message m

SA finally checks whether the zi reported by each participant matches with their committed shares (Dij, Eij) and their public key shares Yi . If each participant has issued the correct zi, then the sum of the zi values together with c constitutes the Schnorr signature on m. This signature will be correctly verified by a verifier who does not know that FROST was used to generate the signature, and who verifies it with Y as the public key using the standard one-sided Schnorr verification equation (Section 2.4).
Handling transient pending shares. Since each nonce and commitment share generated in the preprocessing phase described in the preprocessing algorithm can be used at most once, the participant removes these values after using them in the signing operation, as shown in step 5 of the signing algorithm. An accidental reuse of (dij, eij) leads to the exposure of the participant's long-term secret si, so the participant must securely remove them and defend against snapshot rollback attacks as any Schnorr signature implementation would. However, if the SA chooses to reuse a commitment set (dij, eij) during the signing protocol, doing so simply causes the participant Pi to abort the protocol and therefore does not increase the SA's power.

## Summary

Overall, FROST improves the state of the art for Schnorr threshold signatures by defining a signature protocol that can be optimized for (non-broadcast) single-round operations with a preprocessing phase. Unlike many previous Schnorr threshold schemes, FROST remains secure against known forgery attacks without limiting the concurrency of signature operations.