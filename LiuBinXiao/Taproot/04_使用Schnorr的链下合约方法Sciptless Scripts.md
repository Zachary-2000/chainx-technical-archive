## Content Guide

- [Scriptless Scripts](#Scriptless-Scripts)
- [Schnorr Signatures](#Schnorr-Signatures)
- [Adaptor Signatures](#Adaptor-Signatures)
- [Atomic (Cross-chain Swaps) Example with Adaptor Signatures](#Atomic-(Cross-chain-Swaps)-Example-with-Adaptor-Signatures)
- [Summary](#Summary)

## Scriptless Scripts

Scriptless Scripts是数学家 Andrew Poelstra 为了进一步探索 Schnorr 签名数学特性而创造的，它是一种利用Schnorr 签名在链下执行智能合约的方法。目前，智能合约需要整个网络来获取和执行代码逻辑，虽然让每个人都执行脚本非常简单，但其实完全可以不需要区块链执行，而且脚本逻辑本身是公开的，它从根本上来说也不够隐私，在链下执行智能合约逻辑正是Scriptless Scripts方法的目标。为了在链下实现智能合约，支出条件不是由区块链执行的，而是由各方人员自行执行的。只有当合约各方同意并满足条件后，他们才会签署执行最终交易。而对于区块链来说，它看起来就像一个普通的签名，只有参与者知道发生了什么。

## Schnorr Signatures

使用 Schnorr 签名，你可以拥有一个公钥，但它是许多不同人公钥的总和。由此产生的公钥是一个可以验证签名的公钥——只有所有参与者可以合作产生签名，所以它仍然是一个多重签名。多重签名（multisig）有多个产生签名的参与者，每个参与者可能会产生一个单独的签名并将它们连接起来，形成一个多重签名。当然，这里我们需要先看看Schnorr 签名的基础部分。首先，签名者有一个私钥 x 和一个随机的私有 nonce r， G 是离散对数群的生成器，R=rG是公共随机数，P=xG是公钥。然后可以像下面这样简单地线性计算消息 m 的签名 s：

![schnorr](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1627960316485-1627960316469.png)

验证方程会将方程中的每一项乘以 G 并考虑密码假设（离散对数），也就是其中的G可以使用乘法但无法使用除法，从而防止破译。

![verify](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1627960381309-1627960381308.png)

椭圆曲线数字签名算法 (ECDSA) 签名在 x 和 r 中不是线性的，因此作用不大。但是对于Schnorr签名，所有的s会聚合成多重签名，仅需像下面这样简单计算即可：

![sum](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1627960439005-1627960439004.png)

可以明显地看出，这些签名只需要在链下进行计算，本质上就是Scriptless Scripts。这样多个参与者的独立公钥会聚合形成一个单独的密钥和签名，在发布时不会泄露参与人数和原始公钥的详细信息。

## Adaptor Signatures

Schnorr的多重签名经过修改可以产生一个适配器签名，它将作为所有Scriptless Scripts功能的基础部分。

适配器签名会在签名中 "隐藏一个秘密"，这样，当收款人索要资金时，他们必须向付款人透露这个秘密。假设t是支付秘密（接收方知道），T=t*G是与这个秘密相关的点/公钥（双方都知道）。与正常的支付一样，资金的支付方/发送方将产生一个向接收方发送资金交易的Schnorr签名。与正常支付不同的是，发送方将使用T来调整他们的签名，而接收方只能通过使用秘密t来修复这个签名，以获得一个有效的签名。这个生成的无效签名将被发送到接收方（而不是区块链），接收方将在使用现在有效的签名向区块链广播交易之前使用他们的秘密修复签名。因此适配器签名不是完整的有效签名，而是承诺发布的签名将揭示秘密。这个概念类似于原子交换的概念，只是没有实现任何脚本。

在这里，修改了 Schnorr 多重签名结构，使得第一方生成：

![gen](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1627960536172-1627960536172.png)

其中 t 是共享秘密，G 是离散对数群的生成器，r 是随机数。
使用此信息，第二方生成：

![gen2](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1627960571916-1627960571916.png)

要交换的硬币包含在消息 m 中。第一方现在可以计算完整的签名 s使得

![s](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1627960611803-1627960611802.png)

然后第一方计算并将适配器签名 s' 发布给第二方（以及其他任何人）

![s'](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1627960646893-1627960646892.png)

第二方可以通过 s'G 来验证适配器签名 s'

![s'G](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1627960688370-1627960688369.png)

然而，这不是一个有效的签名，因为散列的随机数点是 R+T 而不是 R。第二方无法从中检索到有效签名，并且需要 ECDLP 求解来恢复 s'+t，但这实际上是不可能的。而在第一方广播 s 以领取消息 m 内的硬币后，第二方通过下面公式可以计算出密钥t：

![t](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/1627960725200-1627960725192.png)

## Atomic (Cross-chain Swaps) Example with Adaptor Signatures

适配器签名的一个简单但强大的应用是创建一个跨链的原子交换，它允许资产的无信任交换。适配器签名是一个可以由一个值抵消的签名，一旦与真正的签名相结合，就可以让接收者计算出发送者的密钥t。适配器签名可以被验证为真实的，但在真实签名公布之前不会透露任何信息。这些适配器签名使我们能够在跨链原子交换中实现原子性。适应者签名的持有者可以放心，如果他们的对手认领他们的硬币，他们将能够认领他们的硬币。

这里给一个简单的例子，假设Alice 在特定区块链上拥有一定数量的硬币； Bob 在另一个区块链上也有一定数量的硬币。爱丽丝和鲍勃想要进行原子交换。但是，两个区块链都不知道对方，也无法验证彼此的交易。实现这一目标的经典方法涉及使用区块链的脚本系统进行哈希原像质询，然后在两侧显示相同的原像。一旦爱丽丝知道原像，她就会拿出它来拿走她的硬币。然后鲍勃将它从一条链复制到另一条链以获取他的硬币。使用适配器签名，可以通过更简单的方式实现相同的结果。在这种情况下，Alice 和 Bob 都将他们的硬币放在每个区块链的两个输出中的两个上。他们并行签署多重签名协议，然后 Bob 使用相同的值 T 向 Alice 提供每一方的适配器签名。这意味着 Bob 要取走他的硬币，他需要透露 t；为了让爱丽丝拿走她的硬币，她需要透露 T。然后鲍勃替换其中一个签名并发布 t，拿走他的硬币。 Alice 根据区块链上可见的最终签名计算 t，并使用它来显示另一个签名，给 Alice 她的硬币。

由此可以看出适配器签名实现了原子性。区块链上没有明确的哈希或原像，但人们仍然能够交换信息，并且不需要脚本属性还实现了隐私。

## Summary

Scriptless Scripts比标准智能合约的扩展性更好，因为合约的执行发生在链外。通过将此执行推送给关心它的人，就不需要消耗公共计算资源去存储合约数据和执行合约。在隐私方面，将智能合约的逻辑和执行从链上转移到链下会增加隐私。在链上时，智能合约的许多信息会共享给整个网络，这些信息包括参与者的数量和地址，以及转移的金额。通过将智能合约移到链下，网络只知道参与者同意了合约并且相关交易是有效的。合约中的细节只有当事人才知道，可见的东西与其他普通交易没有区别。这为我们提供了一种称为可否认性的特性，这意味着对于中立的观察者来说，交易与普通交易无法区分。在效率方面，Scriptless Scripts最大限度地减少了需要验证和存储在链上的数据量。通过将智能合约移到链下，全节点的开销更少，用户的交易费用更低 。

