# Pay-to-Taproot (P2TR)

## P2TR介绍

​		Pay-to-Taproot（P2TR）是一种ScriptPubKey，它将比特币锁定在一个脚本上，允许用户向 Schnorr 公钥或各种其他脚本的 Merkle 根支付。表面上看，一个P2TR输出将比特币锁定在一个施诺尔公钥上，我们假设为Q。然而，这个公钥Q实际上是一个公钥P和一个公钥M的总和，M是由其他ScriptPubKeys列表的Merkle根计算出来的。P2TR 输出中的比特币可以通过发布公钥 P 的签名或满足 Merkle 树中包含的脚本之一来花费，前者称为密钥路径，后者则是脚本路径。虽然P2TR的输出可能有许多种方式，但只有被使用的那一种会被公开，这样可以为其他未使用的替代方案保持隐私。此外，由于Schnorr密钥聚合特性，公钥P本身可以是一个聚合密钥，公钥P作为一个聚合密钥或单一密钥的状态永远不会被透露，因为所有的P2TR输出都是彼此相似的，这样将破坏许多链分析启发式方法，增强用户的隐私。

## 其他支付方式

### P2PKH

​		Pay-to-Public-Key-Hash（P2PKH）是一种ScriptPubKey，它将比特币锁定在一个公钥的哈希（比特币地址）上。例如，Alice想在P2PKH交易中向Bob发送1个BTC，Bob向Alice提供他钱包中的一个地址，然后Bob的地址会被包括在交易中。当Bob试图花费他收到的比特币时，他必须用对应于公钥的私钥来签署交易，公钥的哈希值与Alice交易中提供的哈希值一致。

### P2WPKH

​		Pay-to-Witness-Public-Key-Hash (P2WPKH) 是一种 ScriptPubKey，用于将比特币锁定到 SegWit 地址。 P2WPKH 交易在大多数方面类似于 P2PKH 交易；它仍然将比特币锁定到公钥的哈希值。主要区别在于 P2WPKH 使用 SegWit。这意味着所有输入的 ScriptSig（解锁比特币的脚本）被移出交易主体并进入见证部分，并称为脚本见证。这些数据仍然记录在区块链上，但数据产生的费用会低于常规数据，使得 SegWit 交易比常规交易便宜。

### P2SH

​		Pay-to-Script-Hash (P2SH) 是一种 ScriptPubKey， 主要用于多重签名钱包，制作输出脚本逻辑，在接受交易之前检查多重签名。例如，如果 Alice 在 P2SH 交易中向 Bob 发送 1 BTC，她会将花费比特币所需脚本的哈希值包含在交易中。此脚本可能需要 Bob 的私钥和/或许多其他人的签名。当 Bob 想要花费他从 Alice 那里收到的比特币时，他会重建 Alice 用来发送比特币的脚本哈希，并使用脚本所需的任何私钥对交易进行签名。P2SH 非常灵活，因为它允许用户构建任意脚本。此外，交易的发送者不需要知道他们发送到什么脚本类型。在上面的示例中，Bob 可以线下构建他想要的脚本，并且只向 Alice 发送该脚本的哈希值，从而为 Bob 保留更多隐私。

### P2WSH

​		Pay-to-Witness-Script-Hash (P2WSH) 是一种在大多数方面类似于 P2SH 交易的交易类型，除了它使用 SegWit。与 P2SH 交易一样，P2WSH 交易将比特币锁定到脚本的哈希值。为了花费这个比特币，花费者必须出示称为 RedeemScript 的脚本和任何必需的签名。在技术层面上，P2WSH 实际上描述了用于将比特币锁定到 SegWit 脚本哈希的 ScriptPubKey。

## P2TR优点

![P2TR-compare](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Platdot/1626675952582-1626675952580.png)

​		通过比较不同类型的签名大小，可以看出在单一签名上使用P2TR是要比同等的P2WPKH要大一点的，但仔细观察会发现，对单一签名的钱包用户和整个网络来说，使用P2TR有很多好处：

- 花费更便宜：在投入层面上，花费一个单一签名的P2TR UTXO比花费一个P2WPKH UTXO要少15%左右。像上表这样过于简单的分析隐藏了一个细节，即花费者不能选择他们被要求支付的地址，所以如果你留在P2WPKH上，而其他人都升级到P2TR，你的2进2出交易的实际典型大小将是232.5vbytes，而所有P2TR交易仍然只有211.5vbytes。
- 隐私性：虽然早期采用者改用新的脚本格式时，会失去一些隐私，但改用taproot的用户也会立即得到隐私性的提升。你的交易将能够看起来与从事新的LN通道、更有效的DLCs、安全的多重签名、各种巧妙的钱包备份恢复方案或其他一百种开创性发展的人没有区别。现在使用P2TR进行单签名，也允许你的钱包在以后升级到多签名、tapscripts、LN支持或其他功能，而不影响你现有用户的隐私。无论是旧版本还是新版本的软件收到 UTXO 都没有关系——两个 UTXO 在链上看起来都是一样的。
- 对硬件签名设备来说更方便：自重新发现费用超额支付攻击以来，一些硬件签署设备拒绝签署交易，除非该交易中花费的每个UTXO都有元数据，其中包含产生该UTXO的整个交易的重要部分的副本。而Taproot 消除了费用超额支付攻击的潜在漏洞，因此可以显着提高硬件签名者的性能。
- 更多的可预测性：P2PKH和P2WPKH UTXO的ECDSA签名可以有不同的大小，由于钱包需要在创建签名之前选择交易的费率，大多数钱包只是假设最坏情况下的签名大小，因此接受较小的签名时将略微多付一些费用。而对于P2TR，签名的大小是事先知道的，允许钱包可以选择一个精确的feerate。
- 帮助完整的节点：比特币系统的整体安全性取决于大部分比特币用户使用自己的节点验证每笔确认的交易，也包括验证您钱包创建的交易。Taproot的schnorr签名可以有效地进行批量验证，在同步区块的过程中，节点验证签名时需要消耗的CPU周期减少了约1/2。就算你拒绝了上述的所有优点，也要考虑一下使用taproot去帮助运行完整节点的人。

## 支持P2TR

对于已经支持接收和花费v0 segwit P2WPKH输出的钱包来说，升级到v1 segwit P2TR进行单一签名应该很容易，以下是主要的步骤：
- 使用新的BIP32密钥推导路径：强烈建议为P2TR公钥使用一个新的推导路径（例如由BIP86定义的），如果你在ECDSA和schnorr签名中使用相同的密钥，可能会被攻击。
- 通过哈希值来调整你的公钥：虽然技术上不需要单签名，特别是当你的所有密钥都来自随机选择的BIP32种子时，BIP341建议将你的密钥提交到一个不可消耗的scripthash树。这就像使用椭圆曲线加法运算一样简单，将你的公钥与该密钥的哈希值的曲线点相加。遵守这个建议的好处就是如果你以后要增加对无脚本多签名的支持，或者增加对tr()描述符的支持，你将能够使用同样的代码。
- 创建你的地址并对其进行监控：使用bech32m来创建你的地址。支付将被发送到scriptPubKey OP_1 <tweaked_pubkey>。你可以使用用于扫描 v0 隔离见证地址（如 P2WPKH）的任何方法来扫描支付脚本的交易。
- 创建一个支出交易：taproot的所有非见证字段都和P2WPKH的一样，所以你不需要担心交易序列化的变化。
- 创建一个签名信息：这是对支出交易的数据的承诺。大部分数据与你为P2WPKH交易所签署的数据相同，但字段的顺序被改变，还有一些额外的东西被签署。实现这一点只是一个序列化和散列各种数据的问题，所以编写代码应该很容易。
- 签署签名信息的哈希值：现在已经有许多不同的方法用来创建Schnorr签名了。因此当前最好的方法不是 "推出你自己的方法"，而是使用你信任的、经过严格审查的库中的功能。但是，如果你由于某种原因不能这样做，BIP340提供了一种算法，如果你已经有了制作ECDSA签名的基础，那么这种算法应该很容易实现。当你有了你的签名，把它放在输入的见证数据中，然后发送你的支出交易。

## 总结

​		Pay-to-Taproot (P2TR)输出是版本为 1 的SegWit 输出，以后所有的 Taproot 交易都是 SegWit 交易，因此对于开发者，优先尝试一下P2TR是必要的。在taproot在709,632区块激活之前，你就可以使用testnet、公共默认标志或Bitcoin Core的私有regtest模式测试你的代码。

