# How does frontier manage the substrate account and ethereum account

## 1 Introduction
[frontier](https://github.com/paritytech/frontier) is an ethereum compatibility layer based on substrate, which can smoothly migrate the dapp deployed on ethereum to substrate, and frontier is fully compatible with eth api. When the eth transaction is executed through the eth api  provided by frontier, how is the ethereum account (or address) saved on the substrate? Can the substrate account and the ethereum account transfer balance to each other?

## 2. frontier's architecture

The frontier implementation is mainly composed of the following components:

- runtime: 
  - evm: The reference is [SputnikVM](https://github.com/rust-blockchain/evm) EVM engine
  - pallet-evm: Encapsulates the context in the substrate environment, such as the handling of account balances
  - pallet-ethereum: Store eth transactions and their receipts, convert eth transactions into substrate transactions
- rpc module: ethApi, ethFilterApi, netApi, ethPubSubApi, web3Api

![image](https://user-images.githubusercontent.com/8869892/128314802-21f85c2b-a956-4f1e-9732-78d5ce7ad0b8.png)

As shown in the figure, the substrate account and the ethereum account share pallet-balances, which means that the ethereum account is mapped to the substrate account  on the substrate.

`pallet-evm` provides `AddressMapping` association type, which can customize the method of converting ethereum account to substrate account.

```
/// EVM module trait
pub trait Config: frame_system::Config + pallet_timestamp::Config {
	/// Calculator for current gas price.
	type FeeCalculator: FeeCalculator;

	/// Maps Ethereum gas to Substrate weight.
	type GasWeightMapping: GasWeightMapping;

	/// Block number to block hash.
	type BlockHashMapping: BlockHashMapping;

	/// Allow the origin to call on behalf of given address.
	type CallOrigin: EnsureAddressOrigin<Self::Origin>;
	/// Allow the origin to withdraw on behalf of given address.
	type WithdrawOrigin: EnsureAddressOrigin<Self::Origin, Success=Self::AccountId>;

	/// Mapping from address to account id.
	type AddressMapping: AddressMapping<Self::AccountId>;
	/// Currency type for withdraw and balance storage.
	type Currency: Currency<Self::AccountId>;

	/// The overarching event type.
	type Event: From<Event<Self>> + Into<<Self as frame_system::Config>::Event>;
	/// Precompiles associated with this EVM engine.
	type Precompiles: PrecompileSet;
	/// Chain ID of EVM.
	type ChainId: Get<u64>;
	/// The block gas limit. Can be a simple constant, or an adjustment algorithm in another pallet.
	type BlockGasLimit: Get<U256>;
	/// EVM execution runner.
	type Runner: Runner<Self>;

	/// To handle fee deduction for EVM transactions. An example is this pallet being used by `pallet_ethereum`
	/// where the chain implementing `pallet_ethereum` should be able to configure what happens to the fees
	/// Similar to `OnChargeTransaction` of `pallet_transaction_payment`
	type OnChargeTransaction: OnChargeEVMTransaction<Self>;

	/// Find author for the current block.
	type FindAuthor: FindAuthor<H160>;

	/// EVM config used in the module.
	fn config() -> &'static EvmConfig {
		&ISTANBUL_CONFIG
	}
}
```

## 3. Generation of substrate account and ethereum account
First, look at the process of ethereum account generation: `ecdsa-secp256k1 private key` -> `ecdsa-secp256k1 public key` -> `ethereum AccountId20` -> `Hex format address`

- Step 1:  private key
ã€€example of 256bit private key generated by pseudo-random number (256bit, hexadecimal, 32 bytes)

  ```
  18e14a7b6a307f426a94f8114701e7c8e774e7f9a47e2c2035db29a206321725
  ```

- Step 2: public key
   
   - 1.use the ECDSA-secp256k1,  map the private key (32 bytes) to the public key (65 bytes) (prefix 04 + public_key_X + public_key_Y):
  ```
  04
  50863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352
  2cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6
  ```
    
     - 2.skip the first byte (prefix `04`), take the remaining 64-byte public key (uncompressed public key) to hash, and calculate the Keccak-256 hash value (32bytes) of the public key:

  ```
  fc12ad814631ba689f7abe671016f75c54c607f082ae6b0881fac0abeda21781
  ```

    - 3.take the last 20 bytes of the result of the previous step, which is the `AccountId20` stored on the chain:

  ```
  1016f75c54c607f082ae6b0881fac0abeda21781
  ```

- Step 3: the Hex format of `AccountId20` is the ethereum address:

  ```
  0x1016f75c54c607f082ae6b0881fac0abeda21781
  ```

Similarly, the process of substrate account generation: `sr25519 private key` -> `sr25519 public key` -> `substrate AccountId32` -> `Base58 format address`
- Step 1: private key

- Step 2: public key: sr25519 private key generates a 32-byte public key, which is the `AccountId32` stored on the chain

- Step 3: the Base58 format  of `AccountId32`, which is the substrate address.


## 3. Transfer between the substrate account and the ethereum account

We already know that the ethereum account is converted into a substrate account through a custom method, and pallet-balances are shared.

![image](https://user-images.githubusercontent.com/8869892/128326450-9efdc8b3-0e33-424f-838b-9c8ad5816c79.png)


As shown in the figure, the transfer  between `AccountId_substrate` and `AccountId_ethereum`
- [x] `AccountId_substrate ->  AccountId_substrate`:  substrate api (sr25519 signed tx), path-1 in the diagram
- [x] `AccountId_substrate ->  AccountId_ethereum`:  substrate api (sr25519 signed tx), path-1 in the diagram
- [x] `AccountId_ethereum -> AccountId_ethereum`:  eth api (ecdsa signed tx),  path-2 in the diagram
- [ ] `AccountId_ethereum -> AccountId_substrate`: The ecdsa account provided by substrate is not compatible with the ethereum account. Although frontier provides the path 3  in the diagram (the withdraw method of pallet-evm) , it is not universal. You need to customize the `Ecdsa Signature` to be compatible with the ethereum account, such as Moonbeam's solution.

## 4. How does Minix handle the transfer of ethereum account to substrate account?
In the figure in the previous section, two solutions, path 3 and path 4, are provided to deal with `AccountId_ethereum -> AccountId_substrate`

- path-3: Combined with the method of converting a custom ethereum account to a substrate account, modify minix's MultiSignature compatible ethereum account, and complete the transfer from the ethereum account to the substrate account through the withdraw method of pallet-evm.

- path-4: Customize an unsigned `withdraw_ecdsa` method, through the `Call` of substrate, assemble the transfer call, sign with the ecdsa private key, `withdraw_ecdsa` completes the validity check of path-4 and the transfer from the ethereum account to the substrate account.

In addition, minix also needs to handle the conversion between AccountId_substrate balance and AccountId_ethereum balance.

Minix uses 8-bit tokenDecimals, while ethereum uses 18-bit tokenDecimals

- Solution 1: Upgrade minix's tokenDecimals to 18 bits.

- Solution 2: There is no upper limit on the total amount of mini, turn off the transfer of `AccountId_ethereum -> AccountId_substrate` to reduce the impact.

