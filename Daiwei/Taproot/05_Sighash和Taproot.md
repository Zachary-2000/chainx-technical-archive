# Sighash和Taproot

## Sighash简介

​	为了确保没有人未经许可而花费持有者的 BTC，需要进行签名才能完成一次BTC花费。由于一个交易的输入、输出都可能具有多个，那么签名也具有多种类型。SIGHASH 就是一种类型标志，用于指示交易的哪一部分被签名。 通过选择不同的SIGHASH，可以有效的应对不同的应用场景。

## Sighash用途

![sighash_1](https://github.com/AAweidai/PictureBed/blob/master/taproot/sighash_1.png?raw=1)

​	尽管比特币网络仅定义了四个值，但SIGHASH_ANYONECANPAY通过按位 | 可以将其与前三个值组合在一起，导致目前SIGHASH总共有六个可能的值。如上图所示，是可以添加到交易中的数字签名的 6 种不同标志组合。 值得注意的是，一个交易的不同的输入可以使用不同的 SIGHASH 标志，从而实现支出条件的复杂组合。

![sighash_2](https://github.com/AAweidai/PictureBed/blob/master/taproot/sighash_2.png?raw=1)

1. SIGHASH_ALL（0x01）：这是我们所知道的每个用户的钱包的默认设置。它对每个交易的所有输入和输出进行签名，对交易的任何更改都将使签名无效。这实质上是“我只同意使用输入和输出必须精确，接受地址才能得到的比特币”。这是我们每个人常用的交易签名类型，通过花费特定的输入来创建特定的输出。

2. SIGHASH_NONE（0x02）：这将签署交易的所有输入，但不签署任何输出。实际上，它会产生一条授权语：“我可以参与这项交易，但是我并不特别在意它的去向”。从表面上看这似乎是不安全的，似乎没有签署任何输出就在浪费金钱。确实，如果你仅用一个输入创建一个tx并用对其进行签名SIGHASH_NONE，那么矿工将能够简单地将输出更改为他们控制的输出。该结构相当于创建特定金额的“不记名支票”或“空白支票”。它对输入进行承诺，但允许更改输出锁定脚本。任何人都可以将自己的比特币地址写入输出锁定脚本并兑换交易。可用的应用场景是满足“我同意花我的钱，只要其他所有人也花钱”的情形。预计其他签名者中的一个将随后使用该笔SIGHASH_ALL交易来确保交易的所有输出，并将款项发送至双方同意的输出集。

3. SIGHASH_SINGLE（0x03）：这种签名对所有输入以及一个相应的输出进行签名。相应的输出是与签名具有相同索引的输出（即，如果您的输入为vin 0，则你要签名的输出必须为vout 0）。这实际上是说：“只要这笔钱都到了这个地址，我同意参加所有这些输入的交易”。可用的应用场景是A和B需要向某人支付1.5 BTC，A出资1 BTC。B出资0.5BTC。因此，A可以使用SIGHASH_SINGLE创建1个BTC输入和一个1.5 BTC输出到需要付款的人的交易。然后，B可以为其更改地址添加输出，并使用SIGHASH_ALL或SIGHASH_SINGLE来完成交易。

4. SIGHASH_ALL | SIGHASH_ANYONECANPAY（0x81）：与相似SIGHASH_ALL，并对所有输出进行签名。但是，它仅签名一个输入。从本质上说，“只要以下接收者收到这些款项，我就同意参加此交易。我不在乎此交易的任何其他投入。可用的应用的场景是这种结构可以用来做“众筹”交易，试图筹集资金的人可以用单笔输出来构建一个交易，单笔输出将“目标”金额付给众筹发起人。这样的交易显然是无效的，因为它没有输入。但是现在其他人可以添加自己的输入来修改它，实现捐赠。他们用ALL | ANYONECANPAY签名自己的输入，除非收集到足够的输入以达到输出的价值，否则交易无效，每次捐赠是一项“抵押”，直到募集到整个目标金额，筹款人才能收取。

5. SIGHASH_NONE | SIGHASH_ANYONECANPAY（0x82）：与相似SIGHASH_NONE，但仅在其中输入一个签名。这本质上就像在说：“我可以发送此BTC。实际上，我甚至不在乎它是否在此交易中发送。这是签名的便条，说包括该笔交易在内的任何交易都可以花费此BTC”。可用的应用场景是不提供任何保证，只用作花费证明。这样的签名允许任何人定义输入，并将该输入包括在具有任意输出的任何其他签名中。通过做出这样的签名，可以在没有任何控制的情况下花费BTC。

6. SIGHASH_SINGLE | SIGHASH_ANYONECANPAY（0x83）：类似SIGHASH_SINGLE，不同之处在于，它仅对包含它的输入和相应的输出进行签名。这表示“我绝对想将这么多的BTC移至该输出，但是我不在乎此交易中的任何其他输入和输出”。可用应用场景是A向B转账染色币：

   A用一个输入和一个输出创建一个交易：

   - 输入0：一个来自A的染色币

   - 输出0： 一个比特币给到A

   B看到A的交易可以添加交易：

   - 输入1：一个来自B的比特币

   - 输出1：一个染色币给到B

   本质上讲，这允许A持有的1染色币的输入进行签名，并以1 BTC输出至其控制的地址。然后，A发布此无效的交易，无效的原因是因为没有1 BTC的输入。最后，任何想要购买1个BTC的染色币的人都可以添加一个大于等于1 BTC的输入，一个要求1染色币的输出从而完成这笔交易。


## Sighash和Taproot

​	在bip118中提议引入一种新型的SIGHASH叫做SIGHASH_ANYPREVOUT。此种SIGHASH描述了一种用于 tapscript (BIP 342) 交易的新型公钥。 它允许这些公钥的签名不承诺所花费的确切 UTXO。 即通过删除先前输出（以及可选的见证脚本 和值)，允许将签名交易动态重新绑定到另一个需要相同密钥授权的先前输出。并且，此种SIGHASH标志是从SIGHASH_NOINPUT重命名为而来，以反映虽然任何 prevout 都可能与签名一起使用，但输入的某些方面仍然被提交，即输入 nSequence 值，以及支出 条件和金额。

## 总结

​	总的来看，Sighash是一种签名类型标志。利用不同的签名类型，我们可以选择对交易的输入和输出的不同部分进行签名，从而有效的在不同场景中完成BTC的花费。